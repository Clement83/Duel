#include <SPI.h>
#include <Gamebuino.h>
Gamebuino gb;
#include <Wire.h>

const byte prince[] PROGMEM = {16,16,0x0,0x0,0x7,0x1,0x8,0x82,0x8,0x84,0x7,0x48,0x2,0x30,0x27,0x30,0x17,0x48,0xF,0x80,0x7,0x0,0x7,0x0,0x7,0x0,0x5,0x0,0x5,0x0,0x5,0x0,0xD,0x80,};
const byte prince1[] PROGMEM = {16,16,0x0,0x0,0x7,0x0,0x8,0x80,0x8,0x80,0x7,0x0,0x2,0x0,0x27,0x20,0x17,0x20,0xF,0xFF,0x7,0x20,0x7,0x20,0x7,0x0,0x5,0x0,0x5,0x0,0x5,0x0,0xD,0x80,};
const byte princeBouclier[] PROGMEM = {16,16,0x0,0x0,0x7,0x0,0x8,0x80,0x8,0xA0,0x7,0x20,0x2,0x30,0x7,0xF0,0x7,0x38,0x17,0xF0,0xF,0x30,0xF,0x20,0x17,0x20,0x25,0x0,0x45,0x0,0x5,0x0,0xD,0x80,};

//const byte WorldSmall[] PROGMEM = {88,48,0xA,0x80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xD,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1C,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x11,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x70,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xC8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xF8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xF0,0x48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x20,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x10,0x48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x20,0x88,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x10,0x48,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x20,0xF8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xF0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x8,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAB,0xA0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xF0,};

const byte Cloud[] PROGMEM = {16,8,0x0,0x7C,0x38,0x82,0x45,0x1,0x82,0x1,0x81,0x1,0x80,0x5,0x40,0x2,0x3F,0xFC,};
const byte Flag[] PROGMEM = {8,16,0x7F,0xAD,0x57,0x2D,0x57,0xAD,0x57,0x2D,0x57,0xFD,0x7,0x5,0x7,0x5,0x7,0x5,};
const byte Sun[] PROGMEM = {16,16,0x8,0x10,0x44,0x22,0x20,0x4,0x13,0xC8,0x84,0x21,0x48,0x12,0x11,0x88,0x12,0x48,0x12,0x48,0x11,0x8A,0x8,0x11,0x44,0x20,0x93,0xC8,0x20,0x4,0x44,0x12,0x8,0x8,};


//Position en X du chevalier
char mapostionX = 0;
//position en X du mechant
char ennemiX = 0;

float xposSun = 5;
#define NB_CLOUD  1
float cloud[NB_CLOUD * 2];

//boolean isInAttkMechant = true;//pour que le mechant ne frappe qu'une foix
boolean isMaster = false;;
boolean paused = true;
boolean disconnected = false;
boolean slave_updated = false;
boolean isMasterAttak = false;
boolean isSlaveAttak = false;
boolean isMasterHint = false;
boolean isSlaveHint = false;
boolean isMasterBouclierOpen = false;
boolean isSlaveBouclierOpen = false;

//multijoueur code 
#define SLAVE_PAUSED 1
#define I_AM_MASTER 2
#define PLAYER_X 10
#define PLAYER_ATT 21
#define PLAYER_BOUCL 22
#define SLAVE_DATA_BUFFER_LENGTH 6

const char strMaster[] PROGMEM = "Host (master)";
const char strSlave[] PROGMEM = "Join (slave)";
const char* const menu[2] PROGMEM = {
  strMaster,
  strSlave
};

void setup()
{
  gb.begin();
 goTitleScreen();
 gb.battery.show = false;
   //can be either master or slave:
  setupMaster();
  setupSlave();
  for(byte i =0;i<NB_CLOUD;i++)
  {
    cloud[i*2] = random(10, 50);
    cloud[i*2+1] = random(-2,5);
  }
}

void goTitleScreen()
{
  gb.titleScreen(F("Duel"));
  initGame();
}
void initGame()
{
  //on met tout le monde en position initiale
  mapostionX = 5;
  ennemiX = 63;
   isMaster = false;
 isMasterAttak = false;
 isSlaveAttak = false;
 isMasterHint = false;
 isSlaveHint = false;
 isMasterBouclierOpen = false;
 isSlaveBouclierOpen = false;
}

void loop(){
  
      paused = true;
    
      switch(gb.menu(menu, 2)){
      case 0: //Host
        paused = false;
        disconnected = false;
        isMaster = true;
        break;
      case 1: //Join
        paused = false;
        disconnected = false;
        isMaster = false;
        break;
      default:
        gb.titleScreen(F("Duel")); //shows the main menu
        break;
      }
  
    while(true)
    {
      if(gb.update())
      {
        
        if(mapostionX>2 && ennemiX<68)
        {
          if(gb.buttons.pressed(BTN_C))
          {
            break;
          }
            if(isMaster)
            {
              updateMasterPlayer();
               updateMaster();
            }
            else 
            {
              updateSlavePlayer();
              updateSlave();
            }
          
          DrawWorld();
        }
        else 
        {
          victorie();
            break;
        }
      }
    }
    //si on appuis sur C on retourne au menu principal
    goTitleScreen();
}


void updateMasterPlayer()
{
  
         if(!paused){
   //BTN_UP, BTN_RIGHT, BTN_DOWN, BTN_LEFT
   if(gb.buttons.repeat(BTN_RIGHT,1))
   {
     //si on appuis sur droite le chevalier va avancer de 1 px : mapostionX++
      if(!gb.collideBitmapBitmap(mapostionX, 28, prince1, ennemiX, 28, prince1))//si je suis pas en collision avec le mechant
         mapostionX++;
   }
   else if  (gb.buttons.repeat(BTN_LEFT,1))
   {
     //je peut aussi reculer :0
     mapostionX--;
   }
   // on ne doit pas sortir de l'ecran
     if(mapostionX<0) mapostionX = 0;
     if(mapostionX>72) mapostionX = 68; // = 84 px de l'ecran de large - 16 px du chevalier
     
   if(gb.buttons.repeat(BTN_A,1))
   {
     //le chevalier donne un coup d'epee
    isMasterAttak = true;
   }
   else  if(gb.buttons.repeat(BTN_B,1))
   {
     //le chevalier donne un coup d'epee
    isMasterBouclierOpen = true;
   }
   else 
   {
     //le chevalier ne donne pas de coup d'epee
    isMasterAttak = false;
     //le chevalier ne donne pas de coup d'epee
    isMasterBouclierOpen = false;
   }
   
   
 
   
   if(isSlaveHint && isSlaveAttak && !isMasterBouclierOpen)
   {
     isSlaveHint = false;
     if( gb.collideBitmapBitmap(mapostionX, 28, prince1, ennemiX, 28, prince1))
     {
       mapostionX -=4;
     }
   }

         }
}

void updateSlavePlayer()
{
         if(!paused){
    if(gb.buttons.repeat(BTN_LEFT,1))
   {
     //si on appuis sur droite le chevalier va avancer de 1 px : mapostionX++
      if(!gb.collideBitmapBitmap(mapostionX, 28, prince1, ennemiX, 28, prince1))//si je suis pas en collision avec le mechant
         ennemiX--;
   }
   else if  (gb.buttons.repeat(BTN_RIGHT,1))
   {
     //je peut aussi reculer :0
     ennemiX++;
   }
   // on ne doit pas sortir de l'ecran
     if(ennemiX<0) ennemiX = 0;
     if(ennemiX>72) ennemiX = 68; // = 84 px de l'ecran de large - 16 px du chevalier
     
   if(gb.buttons.repeat(BTN_A,1))
   {
     //le chevalier donne un coup d'epee
    isSlaveAttak = true;
   }
   else if(gb.buttons.repeat(BTN_B,1))
   {
     //le chevalier donne un coup d'epee
    isSlaveBouclierOpen = true;
   }
   else 
   {
     //le chevalier ne donne pas de coup d'epee
    isSlaveBouclierOpen = false;
     //le chevalier ne donne pas de coup d'epee
    isSlaveAttak = false;
   }
   
   if(isMasterHint && isMasterAttak && !isSlaveBouclierOpen)
   {
     isMasterHint = false;
     if( gb.collideBitmapBitmap(mapostionX, 28, prince1, ennemiX, 28, prince1))
     {
       ennemiX +=4;
     }
   }

         }
}

void DrawWorld()
{
    //on dessine le monde en position 0,0. le monde fait exatement la taille de l'ecran
   
      gb.display.drawLine(0,47,88,47);
      gb.display.drawBitmap(xposSun,0,Sun);
      for(int i= 0; i<88;i++)
       {
         if(((i) %2) == 0)
         {
           gb.display.drawPixel(i,46);
         }
       }
       
      for(byte i =0;i<NB_CLOUD;i++)
      {
        byte x = cloud[i*2];
        byte y = cloud[i*2+1] ;
        gb.display.drawBitmap(x,y,Cloud);
      }
        gb.display.drawBitmap(8,30,Flag);
        gb.display.drawBitmap(48,30,Flag,NOROT,FLIPH);
   
   if(isMasterAttak)
   {
     //le chevalier donne un coup d'epee
    gb.display.drawBitmap(mapostionX,30,prince1);
   }
   else if(isMasterBouclierOpen)
   {
     gb.display.drawBitmap(mapostionX,30,princeBouclier);
    isMasterHint = true;
     
   }
   else  
   {
     //le chevalier ne donne pas de coup d'epee
    gb.display.drawBitmap(mapostionX,30,prince);
    isMasterHint = true;
   }
   
   if(isSlaveAttak)
   {
     //le chevalier donne un coup d'epee
    gb.display.drawBitmap(ennemiX,30,prince1,NOROT,FLIPH);
   }
   else if(isSlaveBouclierOpen)
   {
     gb.display.drawBitmap(mapostionX,30,princeBouclier,NOROT,FLIPH);
    isMasterHint = true;
     
   }
   else 
   {
     //le chevalier ne donne pas de coup d'epee
    gb.display.drawBitmap(ennemiX,30,prince,NOROT,FLIPH);
    isSlaveHint = true;
   }
}


void victorie()
{
  while(true)
  {
    if(gb.update())
    {
      
        if(ennemiX>=68)
        {
          gb.display.println("P1 win !");
        }
        else 
        {
          gb.display.println("P2 win !");
        }
      gb.display.println("Youhou !");
      gb.display.print("appuis sur ");
      gb.display.print("A");
      if(gb.buttons.pressed(BTN_A))
       {
         break;
       }
    }
  }
  goTitleScreen();
  
}
